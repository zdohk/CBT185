ASUB     TITLE 'ASUB - FILL IN ANY SLOT OF THE INCORE TSO AUTH TABLES'
         SPACE 1
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*   Program Name:   ASUB                                              *
*                                                                     *
*  Documentation:   This program is meant to be run as a TSO          *
*                   command, APF authorized, except for the display   *
*                   functions.                                        *
*                                                                     *
*    Environment:   TSO command, APF Authorized.                      *
*                   PUTLINE interface enabled by APUT, EPUTL.         *
*                   This program is non-reentrant.                    *
*                                                                     *
*    Description:   Display an Auth Table entry from the TSO/E "auth" *
*                   program list tables in storage.  Or display the   *
*                   entire table.  Or replace one entry with a new    *
*                   program name.  If you are invoking a display      *
*                   function, then the entire table is shown, unless  *
*                   you enter a number, and then, only that slot is   *
*                   shown.  Only tables manufactured from PARMLIB     *
*                   entries are displayed or changed, not the ones    *
*                   created from IKJTABLS in LPALIB, or from the      *
*                   IKJTABLS load module that was present in an       *
*                   APF-authorized STEPLIB.                           *
*                                                                     *
*       Function:   To substitute one new program name in the global  *
*                   incore TSO auth tables, IKJEFTE2, IKJEFTE8, or    *
*                   IKJEFTAP, IKJEFTNS, or even to the PLATCMD or     *
*                   PLATPGM lists, if they exist.  This is done to    *
*                   any numbered entry of each table.  Or else merely *
*                   display the contents of the entire table, or the  *
*                   contents of any particular numbered entry.        *
*                                                                     *
*                   Also, a blanking function can be performed on     *
*                   the last entry of any table, which is usually     *
*                   blank anyway.  No blanking can be performed on    *
*                   a slot in the middle of a table, because that     *
*                   will invalidate all the table entries after the   *
*                   blanked slot, and it is too dangerous to do,      *
*                   when done irresponsibly.                          *
*                                                                     *
*         Syntax:   ASUB TTA nnn pgmname                              *
*                                                                     *
*                   Where TT is a table code, and A is an action      *
*                   code.                                             *
*                                                                     *
*                   The table code is a nickname for any of the       *
*                   TSO/E auth tables which are incore.  They are:    *
*                                                                     *
*                   E2 - IKJEFTE2 = AUTHCMD                           *
*                   E8 - IKJEFTE8 = AUTHPGM                           *
*                   AP - IKJEFTAP = AUTHTSF                           *
*                   NS - IKJEFTNS = NOTBKGND                          *
*                   PC - FCVE     = PLATCMD                           *
*                   PP - PPVE     = PLATPGM                           *
*                                                                     *
*                   If the action code is B (blank the last           *
*                   entry), then no program name is required.         *
*                                                                     *
*                   If the action code is D (display the last         *
*                   entry), then no program name is required.         *
*                   The default action is to display the entire       *
*                   table, unless a number is entered.  If a          *
*                   number is present, then only that entry           *
*                   number is displayed.  If the number is larger     *
*                   than the number of entries in that particular     *
*                   table, then an informative error message is       *
*                   issued, and the program ends with code = 4.       *
*                                                                     *
*                   If the action code is R (replace the program      *
*                   name) then a number (the table entry number)      *
*                   and a program name are required.  If you want     *
*                   to blank the last slot, instead of putting a      *
*                   program name into it, then use action code B.     *
*                                                                     *
*                   If the PLATCMD or PLATPGM keywords (and at least  *
*                   one name) were not coded in the active IKJTSOxx   *
*                   PARMLIB entry, then there is no control block of  *
*                   names to be pointed to, and therefore no addition *
*                   of names can be made.  The condition is reported. *
*                                                                     *
*             Note:  If an E2, E8, AP, or NS table which is being     *
*                    used by the system, did not come from the        *
*                    IKJTSOxx PARMLIB entry, but it came from the     *
*                    default IKJTABLS entry in LPALIB, then an        *
*                    appropriate error message is displayed, and      *
*                    no action is performed on that table.            *
*                                                                     *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*  Change Log:                                                        *
*                                                                     *
*    2007/10/21 - 1.0  - Initial version - Got it to work.            *
*                                                                     *
*    2009/03/04 - 1.14 - Measure the tables, list the lengths.        *
*                        Count/display the number of entries and      *
*                         perceived blanks.  Try to detect the true   *
*                         end of table in storage, by measuring,      *
*                         even though (for PARMLIB-created tables)    *
*                         we have a listed length.                    *
*                                                                     *
*    2016/10/30 - 1.15 - Allow a table to validly show question       *
*                         marks (?) in a table entry.                 *
*                        So if you want to nullify a table entry      *
*                         effectively, change the entry to a ?        *
*                         using the "xxR" function.  And "xxD"        *
*                         will show the result accurately.            *
*                        I don't want to put all the functionality    *
*                         from TSUB into this program, because this   *
*                         program affects the whole LPAR, whereas     *
*                         TSUB only affects the owning TSO id.        *
*                                                                     *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*       I N S T R E A M    M A C R O S                                *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         YREGS
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*  ---------------------------------------------------------------  *
*    This macro is used to display hex values in a printed report.  *
*  ---------------------------------------------------------------  *
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
&NAME    DS    0H
         STM   R15,R1,HEXSAVE
         LA    R1,&FROM
         LA    R0,&LEN
         LA    R15,&TO
         BAL   R9,HEX
         LM    R15,R1,HEXSAVE
         MEND
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* ------------------------------------------------------------------- *
         MACRO
&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &
               &LEN,                    @LENGTH OF MESSAGE             &
               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &
               &EPA=                    EPUTL EPA
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*  --> E@PUT
.*
.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.
.*
.*
.*  ARGUMENTS: -----------------------------------------------------
.*
.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL
.*
.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)
.*
.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT
.*            COMPATIBILITY.
.*
.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE
.*
.*
.*   EXAMPLES: -----------------------------------------------------
.*
.*      1) APUT  'LITERAL'
.*
.*      2) APUT  (R3),80
.*
.*      3) APUT  LABEL
.*
.*      4) APUT  LABEL,40
.*
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*
.*  LOCAL SET SYMBOLS
.*
         LCLC  &SMA                     MESSAGE ADDRESS (REG)
         LCLC  &SML                     MESSAGE LENGTH (REG)
         LCLC  &SEP                     EPA (REGISTER)
.*
         LCLC  &L1,&L2,&L3              LOCAL LABELS
.*
&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS
&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS
&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS
.*
.*
.*  MESSAGE ADDRESS
.*
         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*
.*                                                          *HMD 11/86*
&LABEL   DS    0H                                           *HMD 11/86*
.*                                                          *HMD 11/86*
.A0500   ANOP                                               *HMD 11/86*
         AIF   ('&MSG' NE '').A2000
         MNOTE 8,'''&MSG='' MISSING / REQUIRED'
         MEXIT
.*
.A2000   ANOP
         AIF   ('&MSG'(1,1) NE '(').A2400
&SMA     SETC  '&MSG'(2,K'&MSG-2)
         LR    R1,&SMA                  @MESSAGE TEXT
         AGO   .A2600
.*
.A2400   ANOP
         AIF   ('&MSG'(1,1) NE '''').A2500
         B     &L3                      BRANCH AROUND MESSAGE
&L2      DC    C&MSG
&L3      DS    0H
         LA    R1,&L2                   @MESSAGE
         AGO   .A2600
.*
.A2500   ANOP
         LA    R1,&MSG                  @MESSAGE TEXT
.A2600   ANOP
.*
.*  MESSAGE LENGTH
.*
         AIF   ('&LEN' NE '').A3000
         AIF   ('&MSG'(1,1) NE '''').A2800
         LA    R0,L'&L2                 MESSAGE LENGTH
         AGO   .A3600
.*
.A2800   ANOP
         AIF   ('&MSG'(1,1) EQ '(').A2900
         LA    R0,L'&MSG                MESSAGE LENGTH
         AGO   .A3600
.*
.A2900   ANOP
         MNOTE 8,'''LEN'' MISSING / REQUIRED'
         MEXIT
.*
.A3000   ANOP
         AIF   ('&LEN'(1,1) NE '(').A3400
&SML     SETC  '&LEN'(2,K'&LEN-2)
         LR    R0,&SML                  MESSAGE LENGTH
         AGO   .A3600
.*
.A3400   ANOP
         LA    R0,&LEN                  MESSAGE LENGTH
.A3600   ANOP
.*
.*  RSA
.*
         AIF   ('&RSA' EQ '').A4900
         ST    R14,&RSA                 SAVE REGS 14
.A4900   ANOP
.*
.*  ENTRY POINT
.*
         AIF   ('&EPA' NE '').A5000
         L     R15,=V(EPUTL)            EPA
         AGO   .A5600
.*
.A5000   AIF   ('&EPA'(1,1) NE '(').A5400
&SEP     SETC  '&EPA'(2,K'&EPA-2)
         LR    R15,&SEP                 EPA
         AGO   .A5600
.*
.A5400   ANOP
         L     R15,&EPA                 EPA
.*
.A5600   ANOP
.*
.*  CALL LINKAGE
.*
.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE
.*
         AIF   ('&RSA' EQ '').A6900
         L     R14,&RSA                 RESTORE R14
.A6900   ANOP
.*
.AMEND   MEND
* ------------------------------------------------------------------- *
ASUB     CSECT
ASUB     AMODE 31
ASUB     RMODE 24
         USING *,R15                                                  *  01493
         B     BEGINN                   Eyecatcher
         DC    CL8'ASUB  - '
VERS#    DC    CL10'Ver 1.15'
         DC    CL1' '
         DC    CL16' &SYSDATE &SYSTIME '
         DC    CL6'HLASM '
         DC    C'&SYSVER'
         DC    C' '
BEGINN   DS    0H
         DROP  R15
         USING ASUB,R12,R11,R10
         STM   R14,R12,12(R13)
         LR    R12,R15                  Set up base registers.
         ST    R1,SAVEPARM              Save CPPL pointer
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LA    R1,SAVEAREA          Point to new save area               01508
         ST    R1,8(,R13)           Forward save area chain pointer      01509
         ST    R13,4(,R1)           Backward save area chain pointer     01510
         LR    R13,R1               New save area address                01511
         B     INITCON              Branch past save area
         SPACE 1
* -----------------------
SAVEAREA DC    18F'0'                                                    01504
* -----------------------
INITCON  DS    0H                   Initialize constants
         MVI   OFFFLAG,X'00'
         MVI   PLATFLG,X'00'
         MVI   NSCHFLG,X'00'
         MVI   LINEB,X'40'
         MVC   CODEPLAC(2),BLANKS
         XC    FSTCOUNT,FSTCOUNT
         XC    FSTNOUNT,FSTNOUNT
         MVC   FSTFIELD(8),BLANKS
         MVI   BLANKS-1,X'40'
         MVC   BLANKS,BLANKS-1
         XC    BLNKCNT,BLNKCNT      Zero the counters
         XC    NTRYCNT,NTRYCNT
         XC    SLOTBIN,SLOTBIN
         MVC   SLOTSAVE,BLANKS
         MVC   FSTNAME,BLANKS
         MVI   CMDBCOPY-1,X'00'
         MVC   CMDBCOPY,CMDBCOPY-1
* -----------------------
         L     R2,16               POINT TO CVT.
         L     R2,0(,R2)           POINT TO TCB/ASCB WORDS
         L     R2,4(,R2)           POINT TO TCB.
         L     R2,X'B4'(,R2)       POINT TO JSCB.
         L     R2,X'108'(,R2)      POINT TO PSCB.
         LA    R2,0(,R2)           CLEAR HIGH BYTE.
         LTR   R2,R2               ANY PSCB?
         BZ    EOJ4                GET OUT.  NOT TSO.
         L     R1,SAVEPARM         Get the address of the CPPL back
         USING CPPL,R1
         L     R0,CPPLUPT          Copy CPPL fields for possible
         ST    R0,SAVEUPT            later use, if needed.
         L     R0,CPPLPSCB
         ST    R0,SAVEPSCB
         L     R0,CPPLECT
         ST    R0,SAVEECT
         LA    R6,0
         DROP  R1
         BAL   R9,PGMTITLE         First display the program title.
         USING PSCB,R2
CHEKAUTH DS    0H
*        B     CONT0               Bypass authorization check
         TM    PSCBATR1,PSCBACCT   ACCT user?
         BO    CONT0               Yes.  Continue.
         TM    PSCBATR1,PSCBCTRL   OPER user?
         BZ    EOJ4                No.  Get out.
         DROP  R2
CONT0    DS    0H                  Get starting addresses for tables
         L     R2,16               Point to CVT
         L     R2,X'9C'(,R2)       Point to TSVT (TSO Vector Table)
         L     R2,X'4C'(,R2)       Point to TPVT
         ST    R2,SAVETPVT         Save TPVT address for later use
         L     R2,X'14'(,R2)       Point to CTLT control block
         ST    R2,SAVECTLT         Save CTLT address for later use
         L     R2,SAVETPVT         Load TPVT address back
         L     R2,X'34'(,R2)       Point to PLATCMD pointer
         LTR   R2,R2               Is there any?
         BZ    NOFCVE              No. Say so.
         ST    R2,SAVEFCVE         Yes. Store the FCVE pointer away.
         OI    PLATFLG,X'01'       Indicate that FCVE exists.
TRYPPVE  DS    0H
         L     R2,SAVETPVT         Load TPVT address back
         L     R2,X'40'(,R2)       Point to PLATPGM pointer
         LTR   R2,R2               Is there any?
         BZ    NOPPVE              No. Say so.
         ST    R2,SAVEPPVE         Yes. Store the PPVE pointer away.
         OI    PLATFLG,X'02'       Indicate that PPVE exists.
TRYPPVEE DS    0H
* ------
*    There doesn't seem to be a way to tell from an old INMXPARM
*    control block itself, that it is the old version.  So we use
*    the position of the active PARMLIB member name in the TPVT.
* ------
         L     R2,SAVETPVT         Load TPVT address back.
         CLC   =C'IKJ',7(R2)       Parmlib member name in old position?
         BNE   NEWSYSTM            No. It's a new TSO/E version
         OI    OLDFLAG,X'01'       Yes. Flag that the system is old.
NEWSYSTM DS    0H
* ------
*    We start scanning for PARMs here.
* ------
         L     R1,SAVEPARM         Original R1 from entry to program.
         LTR   R1,R1               Any CPPL?
         BZ    EOJ8                No. Get out.
         L     R1,0(,R1)           Point to Command Buffer
         LTR   R1,R1               Any Command Buffer?
         BZ    EOJ4                Get out if none.
         LH    R3,0(,R1)           Load length.
         CH    R3,=H'4'            Anything?
         BNH   EOJ4                No.  Get out.
         LR    R5,R3               Length of command + 4
         ICM   R5,14,FULLZERO      Clear high order 3 bytes.
         ST    R1,CMBUFAD          Save Command Buffer Address
         LH    R3,2(,R1)           Load offset.
         ST    R3,OFFSETSV
         SR    R5,R3               Subtract offset from full length+4
         SH    R5,=H'4'            Correct for length of CMDBUFR header
*                                  in the command buffer.
         BC    8,EOJC              Zero, Message
         BC    5,EOJC              Less, or overflow, out.
         ST    R5,CMBUFEND         Store away the number of bytes left
         L     R1,CMBUFAD          Load Command Buffer Address
*
* ----  Copy command buffer into pgm's buffer so we can control it.
*
         STM   R14,R1,SAVE1401     Now save registers 14 thru 1.
         XR    R14,R14             Clear R14.
         LH    R14,0(,R1)          Load full command buffer length.
         S     R14,=F'5'           Subtract 4 for header, 1 for execute
         EX    R14,COPYCMDB        Copy command into pgm's area.
         LM    R14,R1,SAVE1401     Restore registers 14 thru 1.
         B     GOGOGO              Jump over executed instruction.
COPYCMDB MVC   CMDBCOPY(0),4(R1)   <<< Executed >>>
GOGOGO   DS    0H
* ----
         LA    R6,3                Load register for BCT loop.
* >>>
         LA    R1,CMDBCOPY         Point to command in our buffer
         A     R1,OFFSETSV         Add offset, point to subcommands
         ST    R1,CHARSTRT         Store starting point away
* >>>
         LR    R7,R1               Initialize pointer
         LA    R7,0(,R7)           to first character of function name.
         LA    R8,0                Initialize character count
CUTIDLEN CLI   0(R7),X'40'         Is this character a blank?
         BE    AFTFIRST            Yes, end of the first parm.
         CLI   0(R7),X'00'         Is this character hex zero?
         BE    AFTFIRST            Yes, end of command in buffer copy.
         LA    R7,1(,R7)           Bump another character
         LA    R8,1(,R8)           Count another character
         CR    R8,R5               End of command buffer ?
         BNL   AFTFIRST            Yes. Get out now.
         BCT   R6,CUTIDLEN         Try for blank again.
AFTFIRST DS    0H
         MVC   TABCODE(8),BLANKS   Clear field
         BCTR  R8,0                Subtract 1 for execute.
         L     R1,CHARSTRT         Reload R1 to be sure it's correct.
         EX    R8,MOVOUTL          Move entered parameter to program.
         LA    R8,1(,R8)           Restore number of characters
         AR    R1,R8               Point past last search
         ST    R1,CHARCONT         Continue from here
         ST    R8,SAVER8           Save
         ST    R6,SAVER6             the
         ST    R1,SAVER1A              registers
* ---- >
SEEIFPRM DS    0H                  Check if a command is here
         OC    TABCODE(3),BLANKS   Uppercase. Won't affect numbers
         CLI   TABCODE+2,C'R'      Replace the entry in the given slot
         BE    SEEIF0A1
         CLI   TABCODE+2,C'B'      Blank the last slot
         BE    SEEIF0A2
         CLI   TABCODE+2,C'D'      Display contents of last slot
         BE    SEEIF0A3
         B     SEEIF000
SEEIF0A1 DS    0H
         OI    OFFFLAG,X'01'       Replace an entry
         B     SEEIF001
SEEIF0A2 DS    0H
         OI    OFFFLAG,X'02'       Blank entry in the last slot
         B     SEEIF001
SEEIF0A3 DS    0H
         OI    OFFFLAG,X'04'       Display an entry or entries
         B     SEEIF001
SEEIF000 DS    0H                  Wrong function code was entered...
* --- >                            Display what we entered, plus code
         MVC   LINE,LINEB          Clear line
         MVC   LINE(3),TABCODE     Move code in
         HEX   LINE+6,1,OFFFLAG    Display contents of flag
         MVC   LINE+13(35),=C'Program table name + Function code '
         APUT  LINE,48
* --- >
         BAL   R9,ERRORCOD         Indicate error and display syntax.
         B     EOJ4                Get out with code = 4.
SEEIF001 DS    0H                  Which table to change
         MVC   CODEPLAC(2),TABCODE
* --- >                            Display what we entered, plus code
         MVC   LINE,LINEB          Clear line
         MVC   LINE(3),TABCODE     Move code in
         HEX   LINE+6,1,OFFFLAG    Display contents of flag
         MVC   LINE+13(35),=C'Program table name + Function code '
         APUT  LINE,48
* --- >                            Handle each table separately.
         CLC   TABCODE(2),=C'E2'   Change IKJEFTE2?
         BE    E2CHANGE            Yes. Branch.
         CLC   TABCODE(2),=C'E8'   Change IKJEFTE8?
         BE    E8CHANGE            Yes. Branch.
         CLC   TABCODE(2),=C'AP'   Change IKJEFTAP?
         BE    APCHANGE            Yes. Branch.
         CLC   TABCODE(2),=C'PC'   Change PLATCMD?
         BE    PCCHANGE            Yes. Branch.
         CLC   TABCODE(2),=C'PP'   Change PLATPGM?
         BE    PPCHANGE            Yes. Branch.
         CLC   TABCODE(2),=C'NS'   Change IKJEFTNS?
         BE    NSCHANGE            Yes. Branch.
         BAL   R9,ERRORCOD         Indicate error and display syntax.
         B     EOJ4                Invalid code entered.
EOJ      DS    0H                  END OF JOB                            04216
         L     R13,4(,R13)                                               04214
         LR    R15,R5              Put in real return code
         ST    R15,16(,R13)        Shove it where it belongs
         L     R14,12(,R13)        R14 and
         LM    R0,R12,20(R13)        rest of registers
         BR    R14                 Go back to caller
EOJ0     DS    0H                  Return code 0
         MVC   LINE,LINE-1         Clear output area
         MVC   LINE,MESSAGR0       Show Return Code 0
         APUT  MESSAGR0,L'MESSAGR0
         LA    R5,0                Set CC = 0
         B     EOJ                 Now end the program
EOJ4     DS    0H                  Return code 4
         MVC   LINE,LINE-1         Clear output area
         MVC   LINE,MESSAGR4       Show Return Code 4
         APUT  LINE,L'MESSAGR4
         L     R5,FULLFOUR         Set CC = 4                            04215
         B     EOJ                 Now end the program
EOJ8     DS    0H                  Return code 8
         MVC   LINE,LINE-1         Clear output area
         MVC   LINE,MESSAGR8       Show Return Code 8
         APUT  LINE,L'MESSAGR8
         L     R5,FULLEIGT         Set CC = 8                            04215
         B     EOJ                 Now end the program
EOJC     DS    0H                  Return code 12
         MVC   LINE,LINE-1         Clear output area
         MVC   LINE,MESSAGRC       Show Return Code 12
         APUT  LINE,L'MESSAGRC
         L     R5,FULLTWLV         Set CC = 12
         B     EOJ                 Now end the program
** ---------------------------------------------------------------- **
NOTAUTH  DS    0H                     Command not authorized message.
         APUT  MESSAG2C,L'MESSAG2C
         APUT  MESSAG2D,L'MESSAG2D
         B     EOJC
E2CHANGE DS    0H                 Handle the E2 table
         BAL   R9,ADJNEXTP
         BAL   R9,NAMEPARM
         L     R2,SAVECTLT
         LR    R4,R2
         LA    R4,X'8'(,R4)       POINT TO E2 TABLE
         L     R4,0(,R4)
* - -
         ST    R4,TABLSTRT        Store start address of table
         ST    R4,TABLADDR        Store start address of table
         BAL   R9,PRTBLADR        Display table address
         L     R1,TABLSTRT
**-->>
         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.
         BE    E2CHENTY           It is, then we're cool.
         BAL   R9,MISSPGM3        It isn't, then send message saying so
         B     EOJ4               And exit with code = 4.
E2CHENTY DS    0H                 Table was made from a IKJTSOxx entry.
**-->>
         LA    R1,X'10'(,R1)      Bump past header
         ST    R1,TABLSTRT        Store new start address
* - -
         L     R3,X'C'(,R2)       LOAD SIZE OF E2 TABLE
         ST    R3,TABLELEN        Store listed table size
         LTR   R3,R3              Is there any Parmlib-supplied one?
         BZ    NOE2               No. Say so and get out.
         AR    R4,R3              POINT JUST PAST E2 TABLE
* - -
         XR    R5,R5
         LH    R5,X'10'(,R2)      Load number of entries in table
         ST    R5,TABLENUM        Store number of entries
         BAL   R9,MEASUR08        Measure the table
         BAL   R9,LISTLNTH        Print lengths of table
         BAL   R9,PRTNENTR        Print official number of entries
* - -
         XR    R5,R5
         LH    R5,X'12'(,R2)      LOAD SIZE OF E2 ENTRY
* - -
         ST    R5,TABLESIZ        Store size of each entry
* - -
         SR    R4,R5              POINT TO LAST SLOT
         ST    R4,SAVLSLOT
         TM    OFFFLAG,X'04'      Is this just a contents display?
         BZ    E2CHANGX           No. We must do a real change.
         BAL   R9,DISPTABL        Yes. Just display.
         BAL   R9,CHANGED         Message
         B     EOJ0
E2CHANGX DS    0H
         BAL   R9,DISPTABL        Search table for the proper entry.
         BAL   R9,SETTMODE        Do the Key 0 stuff
         BAL   R9,CHANGED         Tell em we changed the values.
         B     EOJ0
E8CHANGE DS    0H                 Handle the E8 table
         BAL   R9,ADJNEXTP
         BAL   R9,NAMEPARM
         L     R2,SAVECTLT
         LR    R4,R2
         LA    R4,X'14'(,R4)      POINT TO E8 TABLE
         L     R4,0(,R4)
* - -
         ST    R4,TABLSTRT        Store start address of table
         ST    R4,TABLADDR        Store start address of table
         BAL   R9,PRTBLADR        Display table address
         L     R1,TABLSTRT
**-->>
         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.
         BE    E8CHENTY           It is, then we're cool.
         BAL   R9,MISSPGM3        It isn't, then send message saying so
         B     EOJ4               And exit with code = 4.
E8CHENTY DS    0H                 Table was made from a IKJTSOxx entry.
**-->>
         LA    R1,X'10'(,R1)      Bump past header
         ST    R1,TABLSTRT        Store new start address
* - -
         L     R3,X'18'(,R2)      Size of E8 table
         ST    R3,TABLELEN        Store listed table size
         LTR   R3,R3              Is there any Parmlib-supplied one?
         BZ    NOE8               No. Say so and get out.
         AR    R4,R3              POINT JUST PAST E8 TABLE
* - -
         XR    R5,R5
         LH    R5,X'1C'(,R2)      Load number of entries in table
         ST    R5,TABLENUM        Store number of entries
         BAL   R9,MEASUR08        Measure the table
         BAL   R9,LISTLNTH        Print lengths of table
         BAL   R9,PRTNENTR        Print official number of entries
* - -
         XR    R5,R5
         LH    R5,X'1E'(,R2)      LOAD SIZE OF E8 ENTRY
* - -
         ST    R5,TABLESIZ        Store size of each entry
* - -
         SR    R4,R5              POINT TO LAST SLOT
         ST    R4,SAVLSLOT
         TM    OFFFLAG,X'04'      Is this just a contents display?
         BZ    E8CHANGX           No. We must do a real change.
         BAL   R9,DISPTABL        Yes. Just display.
         BAL   R9,CHANGED         Message
         B     EOJ0
E8CHANGX DS    0H
         BAL   R9,DISPTABL        Search table for the proper entry.
         BAL   R9,SETTMODE        Do the Key 0 stuff
         BAL   R9,CHANGED         Tell em we changed the values.
         B     EOJ0
APCHANGE DS    0H                 Handle the AP table
         BAL   R9,ADJNEXTP
         BAL   R9,NAMEPARM
         L     R2,SAVECTLT
         LR    R4,R2
         LA    R4,X'2C'(,R4)      POINT TO AP TABLE
         L     R4,0(,R4)
* - -
         ST    R4,TABLSTRT        Store start address of table
         ST    R4,TABLADDR        Store start address of table
         BAL   R9,PRTBLADR        Display table address
         L     R1,TABLSTRT
**-->>
         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.
         BE    APCHENTY           It is, then we're cool.
         BAL   R9,MISSPGM3        It isn't, then send message saying so
         B     EOJ4               And exit with code = 4.
APCHENTY DS    0H                 Table was made from a IKJTSOxx entry.
**-->>
         LA    R1,X'10'(,R1)      Bump past header
         ST    R1,TABLSTRT        Store new start address
* - -
         L     R3,X'30'(,R2)      Size of AP table
         ST    R3,TABLELEN        Store listed table size
         LTR   R3,R3              Is there any Parmlib-supplied one?
         BZ    NOAP               No. Say so and get out.
         AR    R4,R3              POINT JUST PAST AP TABLE
* - -
         XR    R5,R5
         LH    R5,X'34'(,R2)      Load number of entries in table
         ST    R5,TABLENUM        Store number of entries
         BAL   R9,MEASUR08        Measure the table
         BAL   R9,LISTLNTH        Print lengths of table
         BAL   R9,PRTNENTR        Print official number of entries
* - -
         XR    R5,R5
         LH    R5,X'36'(,R2)      LOAD SIZE OF AP ENTRY
* - -
         ST    R5,TABLESIZ        Store size of each entry
* - -
         SR    R4,R5              POINT TO LAST SLOT
         ST    R4,SAVLSLOT
         TM    OFFFLAG,X'04'      Is this just a contents display?
         BZ    APCHANGX           No. We must do a real change.
         BAL   R9,DISPTABL        Yes. Just display.
         BAL   R9,CHANGED         Message
         B     EOJ0
APCHANGX DS    0H
         BAL   R9,DISPTABL        Search table for the proper entry.
         BAL   R9,SETTMODE        Do the Key 0 stuff
         BAL   R9,CHANGED         Tell em we changed the values.
         B     EOJ0
PCCHANGE DS    0H                 Handle the PC table
         TM    PLATFLG,X'01'
         BZ    PCCHAERR
         BAL   R9,ADJNEXTP
         BAL   R9,NAMEPARM
         L     R2,SAVEFCVE        Get the PC table address
         LR    R4,R2              Save it off
* -- >                            Do Display
*        MVC   LINE,LINE-1
         ST    R4,DISPREG
*        HEX   LINE+13,4,DISPREG
*        MVC   LINE(8),=C'SAVEFCVE'
*        APUT  LINE,30
* -- >
         L     R3,X'8'(,R4)
         ST    R3,TABLELEN        Store listed table size
         AR    R4,R3              POINT JUST PAST PC TABLE
* - -
         L     R3,X'C'(,R2)
         ST    R3,TABLENUM
         LA    R3,8
         ST    R3,TABLESIZ
         L     R3,SAVEFCVE
         ST    R3,TABLADDR        Store start address of table
         BAL   R9,PRTBLADR        Display table address
         BAL   R9,MEASUR08        Measure the table
         BAL   R9,LISTLNTH        Print lengths of table
         BAL   R9,PRTNENTR        Print official number of entries
         LA    R3,X'10'(,R3)
         ST    R3,TABLSTRT
* - -
         LA    R5,8
         SR    R4,R5              POINT TO LAST SLOT
         ST    R4,SAVLSLOT
         TM    OFFFLAG,X'04'      Is this just a contents display?
         BZ    PCCHANGX           No. We must do a real change.
         BAL   R9,DISPTABL        Yes. Just display.
         BAL   R9,CHANGED         Message
         B     EOJ0
PCCHANGX DS    0H
         BAL   R9,DISPTABL        Search table for the proper entry.
         BAL   R9,SETTMODE        Do the Key 0 stuff
         BAL   R9,CHANGED         Tell em we changed the values.
         B     EOJ0
PCCHAERR DS    0H
         MVC   LINE,LINE-1
         MVC   LINE(43),=C'PC command not valid if no PC table exists.'
         APUT  LINE,43
         B     EOJ4
PCCHAEND DS    0H
         B     EOJ0
PPCHANGE DS    0H                 Handle the PP table
         TM    PLATFLG,X'02'
         BZ    PPCHAERR
         BAL   R9,ADJNEXTP
         BAL   R9,NAMEPARM
         L     R2,SAVEPPVE        Get the PP table address
         LR    R4,R2              Save it off
* -- >                            Do Display
*        MVC   LINE,LINE-1
         ST    R4,DISPREG
*        HEX   LINE+13,4,DISPREG
*        MVC   LINE(8),=C'SAVEPPVE'
*        APUT  LINE,30
* -- >
         L     R3,X'8'(,R4)
         ST    R3,TABLELEN        Store listed table size
         AR    R4,R3              POINT JUST PAST PP TABLE
* - -
         L     R3,X'C'(,R2)
         ST    R3,TABLENUM
         LA    R3,8
         ST    R3,TABLESIZ
         L     R3,SAVEPPVE
         ST    R3,TABLADDR        Store start address of table
         BAL   R9,PRTBLADR        Display table address
         BAL   R9,MEASUR08        Measure the table
         BAL   R9,LISTLNTH        Print lengths of table
         BAL   R9,PRTNENTR        Print official number of entries
         LA    R3,X'10'(,R3)
         ST    R3,TABLSTRT
* - -
         LA    R5,8
         SR    R4,R5              POINT TO LAST SLOT
         ST    R4,SAVLSLOT
         TM    OFFFLAG,X'04'      Is this just a contents display?
         BZ    PPCHANGX           No. We must do a real change.
         BAL   R9,DISPTABL        Yes. Just display.
         BAL   R9,CHANGED         Message
         B     EOJ0
PPCHANGX DS    0H
         BAL   R9,DISPTABL        Search table for the proper entry.
         BAL   R9,SETTMODE        Do the Key 0 stuff
         BAL   R9,CHANGED         Tell em we changed the values.
         B     EOJ0
PPCHAERR DS    0H
         MVC   LINE,LINE-1
         MVC   LINE(43),=C'PP command not valid if no PP table exists.'
         APUT  LINE,43
         B     EOJ4
PPCHAEND DS    0H
         B     EOJ0
NSCHANGE DS    0H                 Handle the NS table
         BAL   R9,ADJNEXTP
         BAL   R9,NAMEPARM
         L     R2,SAVECTLT
         OI    NSCHFLG,X'01'      Show SETTMODE we're doing NS
         LR    R4,R2              Save location of CTLT
         LA    R4,X'20'(,R4)      Point to NS table address
         L     R4,0(,R4)          Point to NS table
* - -
         ST    R4,TABLSTRT        Store start address of table
         ST    R4,TABLADDR        Store start address of table
         BAL   R9,PRTBLADR        Display table address
         L     R1,TABLSTRT
**-->>
         CLC   =C' PARMLIB',8(R1) Indicator this table is from PARMLIB.
         BE    NSCHENTY           It is, then we're cool.
         BAL   R9,MISSPGM3        It isn't, then send message saying so
         B     EOJ4               And exit with code = 4.
NSCHENTY DS    0H                 Table was made from a IKJTSOxx entry.
**-->>
         LA    R1,X'10'(,R1)
         ST    R1,TABLSTRT        Store new start address
* - -
         L     R3,X'24'(,R2)      Load size of NS table
         ST    R3,TABLELEN        Store listed table size
         LTR   R3,R3              Is there any Parmlib-supplied one?
         BZ    NONS               No. Say so and get out.
         AR    R4,R3              Point just past NS table
* - -
         XR    R5,R5
         LH    R5,X'28'(,R2)      Load number of entries in table
         ST    R5,TABLENUM        Store number of entries
         BAL   R9,MEASUR10        Measure the table
         BAL   R9,LISTLNTH        Print lengths of table
         BAL   R9,PRTNENTR        Print official number of entries
* - -
         XR    R5,R5              Clear register
         LH    R5,X'2A'(,R2)      Load size of NS entry
* - -
         ST    R5,TABLESIZ        Store size of each entry
* - -
         SR    R4,R5              Point to Last Slot
         ST    R4,SAVLSLOT        Save location of last slot
         TM    OFFFLAG,X'04'      Is this just a contents display?
         BZ    NSCHANGX           No. We must do a real change.
         BAL   R9,DISPTABL        Yes. Just display.
         BAL   R9,CHANGED         Message
         B     EOJ0
NSCHANGX DS    0H
         BAL   R9,DISPTABL        Search table for the proper entry.
         BAL   R9,SETTMODE        Do the Key 0 stuff
         BAL   R9,CHANGED         Tell em we changed the values.
         B     EOJ0
NOE2     DS    0H                 No Parmlib-supplied table there.
         MVC   LINE,LINE-1
         MVC   LINE(L'MESSAGEP),MESSAGEP
         MVC   LINE+20(2),=C'E2'
         APUT  LINE,L'MESSAGEP
         B     EOJ4
NOE8     DS    0H                 No Parmlib-supplied table there.
         MVC   LINE,LINE-1
         MVC   LINE(L'MESSAGEP),MESSAGEP
         MVC   LINE+20(2),=C'E8'
         APUT  LINE,L'MESSAGEP
         B     EOJ4
NOAP     DS    0H                 No Parmlib-supplied table there.
         MVC   LINE,LINE-1
         MVC   LINE(L'MESSAGEP),MESSAGEP
         MVC   LINE+20(2),=C'AP'
         APUT  LINE,L'MESSAGEP
         B     EOJ4
NONS     DS    0H                 No Parmlib-supplied table there.
         MVC   LINE,LINE-1
         MVC   LINE(L'MESSAGEP),MESSAGEP
         MVC   LINE+20(2),=C'NS'
         APUT  LINE,L'MESSAGEP
         B     EOJ4
NOFCVE   DS    0H
         APUT  =C'No PLATCMD table found',22
         B     TRYPPVE
NOPPVE   DS    0H
         APUT  =C'No PLATPGM table found',22
         B     TRYPPVEE
         B     EOJ0
NOTNUMER DS    0H
         MVC   LINE,LINE-1
         MVC   LINE(L'MESSAGEN),MESSAGEN
         MVC   LINE+21(1),0(R7)
         APUT  LINE,L'MESSAGEN
         B     EOJ4
** ---------------------------------------------------------------- **
SAVEPARM DC    F'0'
SAVETPVT DC    F'0'
SAVECTLT DC    F'0'
SAVEFCVE DC    F'0'
SAVEPPVE DC    F'0'
SAVEUPT  DC    F'0'
SAVEECT  DC    F'0'
SAVEPSCB DC    F'0'
** ---------------------------------------------------------------- **
FULLZERO DC    F'0'
FULLFOUR DC    F'4'
FULLEIGT DC    F'8'
FULLTWLV DC    F'12'
SAVE1401 DC    5F'0'                  More for safety
* - - - - - - - - - - - - - - - - - - - - - - - - *
MOVOUTL  MVC   TABCODE(*-*),0(R1)     EXECUTED
MOVFSTN  MVC   FSTNAME(*-*),0(R3)     EXECUTED
MOVSNDN  MVC   SNDNAME(*-*),0(R1)     EXECUTED
MOVFNUM  MVC   FSTNUME(*-*),0(R3)     EXECUTED
PACK     PACK  WORKA,0(0,3)          <<< EXECUTED >>>                    06758
** ---------------------------------------------------------------- **
* - - - - - - - - - - - - - - - - - - - - - - - - *
*            S U B R O U T I N E S                *
* - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         ST    R9,SAVER9A
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         L     R9,SAVER9A
         BR    R9                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
HEXSAVE  DS    3F                    Register save for HEX macro
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
GETNAMES DS    0H
         ST    R9,SAVER9B
GETNAMST DS    0H                  Get rid of leading blanks
         L     R1,CHARCONT         Point to start of character
         CLI   0(R1),X'40'         Is it a blank?
         BNE   GETNAMNZ            No. Get the entire name.
         LA    R1,1(,R1)           Yes. Bump start place one up.
         ST    R1,CHARCONT         And store the place away for now.
         C     R5,=F'1'            End of cmd buffer one away?
         BNH   EOJ4                Yes. Error.
         BCTR  R5,0                Subtract one from end count
         B     GETNAMST            And loop to find first non-blank.
GETNAMNZ DS    0H                  Got first non-blank. Get whole name.
         LA    R6,8                BCT initial quantity - 8 chars.
         LA    R8,0                Character count
         L     R1,CHARCONT         Load starting place
         LR    R7,R1               Initialize pointer
         LA    R7,0(,R7)           to first character of program name.
GETNAMLU DS    0H                  Loop to get entire name
         CLI   0(R7),X'40'         First blank?
         BE    GETNAMGT            Yes, got whole name.
         CLI   0(R7),X'00'         First hex zeros?
         BE    GETNAMGT            Yes, got whole name.
         CR    R8,R5               End of command buffer?
         BNL   GETNAMGT            Yes. Got all we can get.
         LA    R8,1(,R8)           Bump character counter.
         LA    R7,1(,R7)           Bump where we are.
         BCT   R6,GETNAMLU         Loop back.
GETNAMGT DS    0H
         ST    R8,SAVER8
         ST    R8,FSTCOUNT
         CLC   SAVER8,=F'0'
         BNE   GETREALY
         BAL   R9,MISSPGM2
         B     EOJ4
GETREALY DS    0H
         MVC   FSTCHALF(2),FSTCOUNT+2
         MVC   LINE,LINE-1
         HEX   LINE,4,SAVER8
         MVC   LINE+13(17),=C'Length of command'
         APUT  LINE,30
         L     R3,CHARCONT
         BCTR  R8,0                One less for EXECUTE
         MVC   FSTNAME(8),BLANKS
         EX    R8,MOVFSTN
         OC    FSTNAME(8),BLANKS
         MVC   LINE,LINE-1
         MVC   LINE(8),FSTNAME
         MVC   LINE+13(17),=C'New program name '
         APUT  LINE,30
* - >
GETNAMEN DS    0H
         L     R9,SAVER9B
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
CHANGED  DS    0H                     The "value was changed" message.
         ST    R9,SAVER9C
         TM    OFFFLAG,X'01'
         BO    CHANGEDA
         TM    OFFFLAG,X'02'
         BO    CHANGEDB
         TM    OFFFLAG,X'04'
         BO    CHANGEDD
CHANGEDA DS    0H
         MVC   MESSAG3A+5(4),TABENNUM+6
         MVC   MESSAG3A+13(2),CODEPLAC
         MVC   MESSAG3A+42(8),FSTNAME
         APUT  MESSAG3A,L'MESSAG3A    Tell em we changed the value.
         B     CHANGEND
CHANGEDB DS    0H
         MVC   MESSAG3B+13(2),CODEPLAC
         APUT  MESSAG3B,L'MESSAG3B    Tell em we changed the value.
         B     CHANGEND
CHANGEDD DS    0H
         TM    OFFFLAG,X'04'
         BZ    CHANGEDX
         CLC   SLOTBIN,=F'0'
         BE    CHANGEND
CHANGEDX DS    0H
         MVC   LINE,LINE-1
         MVC   LINE(30),=C'Display of Slot contents.     '
         APUT  LINE,30
CHANGEND DS    0H
         L     R9,SAVER9C
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
NAMEPARM DS    0H
         ST    R9,SAVER9D
         TM    OFFFLAG,X'02'          Are we blanking?
         BO    NAMEPEND               Yes. Don't need a name parameter
         L     R8,SAVER8              Get number of characters used
         CR    R8,R5                  More than what's left?
         BNL   NAMEBAD1               Yes. Error.
         C     R5,=F'3'               Is end bigger than 3?
         BNH   NAMEBAD1               No. Error.
NAMEGOOD DS    0H
         S     R5,=F'3'               Subtract 3 from number till end.
         BAL   R9,GETNUMES            Get the number of the pgm entry.
         TM    OFFFLAG,X'04'          Displaying?
         BO    NAMEPEND               Yes. No names wanted.
         BAL   R9,GETNAMES            Get the name of pgm to shove in.
         B     NAMEPEND
NAMEBAD1 DS    0H
         TM    OFFFLAG,X'04'          Are we displaying?
         BO    NAMEPEND
         BAL   R9,MISSPGM1
         B     EOJ4
NAMEPEND DS    0H
         L     R9,SAVER9D
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ADJNEXTP DS    0H
         ST    R9,SAVER9E
         MVC   CHARSTRT,CHARCONT
         L     R1,CHARSTRT
SEEIFENX DS    0H
         CLI   0(R1),X'40'
         BE    SEEIFENZ
         LA    R1,1(,R1)
         ST    R1,CHARSTRT
         B     SEEIFENX
SEEIFENZ DS    0H
         L     R9,SAVER9E
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         LTORG
************************************************************
PGMTITLE DS    0H                     Display program name
         ST    R9,SAVER9F
         MVC   LINE,LINE-1            Blank line
         MVC   LINE,MESSAGET          Move title line in
         APUT  LINE,L'MESSAGET        And put out to tube
         MVC   LINE,LINE-1            Blank line again
         MVC   LINE,MESSAGEU          Move underlines in
         APUT  LINE,L'MESSAGEU        And put them out also
         L     R9,SAVER9F
         BR    R9                     Return to caller
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
SETTMODE DS    0H
         ST    R9,SAVER9G
* -- >       Test if this command is being run APF Authorized
         STM   R15,R1,SAVE1401     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE1401     Restore registers used by TESTAUTH.
* -- >
* -- >      Key Zero ---- Here's where we change the stuff.
KZ       MODESET KEY=ZERO
* -
         TM    OFFFLAG,X'03'
         BZ    ENDKZ
         TM    NSCHFLG,X'01'
         BO    TENSLOT
EIGHSLOT DS    0H
         L     R3,OURSLOT
         TM    OFFFLAG,X'01'
         BZ    BLANKIT
         CLC   FSTNAME,BLANKS
         BE    ENDKZ
         MVC   0(8,R3),FSTNAME
         B     ENDKZ
BLANKIT  DS    0H
         TM    OFFFLAG,X'02'
         BZ    ENDKZ
         L     R3,SAVLSLOT
         MVC   0(8,R3),BLANKS
         B     ENDKZ
TENSLOT  DS    0H
         L     R3,OURSLOT
         TM    OFFFLAG,X'01'
         BZ    BLANKTEN
         CLC   FSTNAME,BLANKS
         BE    ENDKZ
         MVC   0(2,R3),FSTCHALF
         MVC   2(8,R3),FSTNAME
         B     ENDKZ
BLANKTEN DS    0H
         TM    OFFFLAG,X'02'
         BZ    ENDKZ
         L     R3,SAVLSLOT
         MVC   0(2,R3),=X'FFFF'
         MVC   2(8,R3),BLANKS
         B     ENDKZ
ENDKZ    DS    0H
* -
NZ       MODESET KEY=NZERO
* -- >      Back to ordinary life ----
         L     R9,SAVER9G
         BR    R9                     Return to caller
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ERRORCOD DS    0H
         ST    R9,SAVER9H
         MVC   LINE,LINE-1
         APUT  LINE,30
         APUT  MESSA11L,L'MESSA11L
         APUT  MESSA11M,L'MESSA11M
         APUT  MESSA11P,L'MESSA11P
         APUT  MESSA11A,L'MESSA11A
         APUT  MESSA11C,L'MESSA11C
         APUT  MESSA11D,L'MESSA11D
         APUT  MESSA11F,L'MESSA11F
         APUT  MESSA11I,L'MESSA11I
         APUT  MESSA11K,L'MESSA11K
         APUT  MESSA11J,L'MESSA11J
         APUT  MESSA11N,L'MESSA11N
         APUT  MESSA11O,L'MESSA11O
         L     R9,SAVER9H
         BR    R9                     Return to caller
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
MISSPGM1 DS    0H
         ST    R9,SAVER9I
         MVC   LINE,LINE-1
         APUT  MESSA11G,L'MESSA11G
         L     R9,SAVER9I
         BR    R9                     Return to caller
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
MISSPGM2 DS    0H
         ST    R9,SAVER9J
         MVC   LINE,LINE-1
         APUT  MESSA11E,L'MESSA11E
         L     R9,SAVER9J
         BR    R9                     Return to caller
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
MISSPGM3 DS    0H
         ST    R9,SAVER9K
         MVC   LINE,LINE-1
         APUT  MESSA11H,L'MESSA11H
         L     R9,SAVER9K
         BR    R9                     Return to caller
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
DISPTABL DS    0H                Scan thru the particular table....
         ST    R9,SAVER9L          Save BAL register
         ST    R3,SAVER3A          Save
         ST    R4,SAVER4A             the
         ST    R5,SAVER5A                work
         ST    R6,SAVER6A                   registers.
         TM    OFFFLAG,X'02'       Are we blanking the last entry?
         BO    DISPTEND            Yes. Don't have to scan entire table
         XR    R3,R3               Zero
         XR    R5,R5                  work
         XR    R6,R6                     registers.
DISPTSTR DS    0H
         L     R3,TABLSTRT         Load start address of table
         L     R6,TABLENUM         Load number of entries in table
         L     R5,TABLESIZ         Load size of each entry
         LA    R4,1                Start slot number count at 1
         ST    R4,SLOTNOW          Stort slot number count away
         CLC   SLOTBIN,=F'0'       If there's no slot num in param
         BE    DISPTLUP            Then bypass error checking
         C     R6,SLOTBIN          Compare table size to parm number
         BNL   DISPTLUP            If parm number is LE, then display
DISPTERR DS    0H                  Else error message and out.
         MVC   LINE,LINE-1
         MVC   LINE(22),=C'Slot number specified '
         L     R1,SLOTBIN          Display field
         CVD   R1,CVDAREA          Convert count to printable
         MVC   LINE+22(10),MASK10  Move in the mask
         ED    LINE+22(10),CVDAREA+3 Make it pretty
         MVC   LINE+34(26),=C'is bigger than table size '
         L     R1,TABLENUM         Display field
         CVD   R1,CVDAREA          Convert count to printable
         MVC   LINE+60(10),MASK10  Move in the mask
         ED    LINE+60(10),CVDAREA+3 Make it pretty
         APUT  LINE,72
         B     EOJ4
DISPTLUP DS    0H                  Loop thru the table entries.
         MVC   LINE,LINE-1
         MVC   LINE(2),CODEPLAC
         MVC   LINE+3(19),=C'Table Entry Number:'
         CVD   R4,CVDAREA          Convert count to printable
         MVC   LINE+22(10),MASK10  Move in the mask
         ED    LINE+22(10),CVDAREA+3 Make it pretty
         TM    NSCHFLG,X'01'       Is this the 10-byte NS table entry?
         BO    DISPTBNS            Yes. Handle separately.
         MVC   LINE+34(8),0(R3)
         CLC   LINE+34(8),BLANKS   Is this a blank entry.
         BNE   DISPTBLK            No.
         MVC   LINE+34(8),=C'*empty* '   Yes. Don't just show blanks.
         B     DISPTBLK
DISPTBNS DS    0H
         HEX   LINE+34,2,0(R3)
         MVC   LINE+40(8),2(R3)
         CLC   LINE+40(8),BLANKS   Is this a blank entry.
         BNE   DISPTBLK            No.
         MVC   LINE+40(8),=C'*empty* '   Yes. Don't just show blanks.
DISPTBLK DS    0H                  Search each slot number.
         CLC   SLOTBIN,=F'0'       Has a slot number been specified?
         BE    DISPTYES            No. Just display all the slots.
         CLC   SLOTBIN,SLOTNOW     Yes. Then are we at the one we want?
         BNE   DISPTNOT            No. Just go further and search.
* ---  Save contents of the current slot which was found - below
         LR    R1,R5               Load table entry size
         BCTR  R1,0                One less for execute
         EX    R1,MOVESLOT         Save contents of slot for kicks
         ST    R3,OURSLOT          Store its address - important....
         MVC   TABENNUM(10),MASK10    Save edited version
         ED    TABENNUM(10),CVDAREA+3    of this slot number
         B     DISPTPEX               Branch past executed instruction
MOVESLOT MVC   SLOTSAVE(*-*),0(R3)    EXECUTED
DISPTPEX DS    0H
* ---  Save contents of the current slot which was found - above
DISPTYES DS    0H                  Print this slot entry
         APUT  LINE,52
DISPTNOT DS    0H                  Bump to next slot and loop back.
         LA    R3,0(R5,R3)         Bump to next slot
         LA    R4,1(,R4)           Bump count of slot number
         ST    R4,SLOTNOW          Store new slot number away
         BCT   R6,DISPTLUP         And loop to examine the new slot.
DISPTEND DS    0H
         L     R3,SAVER3A          Restore all the work registers.
         L     R4,SAVER4A
         L     R5,SAVER5A
         L     R6,SAVER6A
         L     R9,SAVER9L          Restore the BAL register.
         BR    R9                  Return to caller
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
GETNUMES DS    0H
         ST    R9,SAVER9M
GETNUMST DS    0H                  Get rid of leading blanks
         L     R1,CHARCONT         Point to start of character
         CLI   0(R1),X'40'         Is it a blank?
         BNE   GETNUMNZ            No. Get the entire name.
         LA    R1,1(,R1)           Yes. Bump start place one up.
         ST    R1,CHARCONT         And store the place away for now.
         C     R5,=F'1'            End of cmd buffer one away?
         BNH   EOJ4                Yes. Error.
         S     R5,=F'1'            Subtract one from end count
         B     GETNUMST            And loop to find first non-blank.
GETNUMNZ DS    0H                  Got first non-blank. Get whole name.
         LA    R6,5                BCT initial quantity - 5 chars.
         LA    R8,0                Character count
         L     R1,CHARCONT         Load starting place
         LR    R7,R1               Initialize pointer
         LA    R7,0(,R7)           to first character of program number
GETNUMLU DS    0H                  Loop to get entire number
         CLI   0(R7),X'40'         First blank?
         BE    GETNUMGT            Yes, got whole number
         CLI   0(R7),X'00'         First hex zeros?
         BE    GETNUMGT            Yes, got whole number
         CR    R8,R5               End of command buffer?
         BNL   GETNUMGT            Yes. Got all we can get.
* --
         CLI   0(R7),X'F0'         Check this parm if numeric.
         BL    NOTNUMER
         CLI   0(R7),X'F9'
         BH    NOTNUMER
* --
         LA    R8,1(,R8)           Bump character counter.
         LA    R7,1(,R7)           Bump where we are.
         BCT   R6,GETNUMLU         Loop back.
GETNUMGT DS    0H                  Got the whole number - examine it.
         ST    R8,SAVER8
         ST    R8,FSTNOUNT         Get halfword value of slot number
         MVC   FSTNHALF(2),FSTNOUNT+2
         L     R3,CHARCONT
         BCTR  R8,0                One less for EXECUTE
         MVC   FSTFIELD(8),BLANKS  5-char number plus 3 blanks
         EX    R8,MOVFNUM          Get the number from the parm
         EX    R8,PACK             Convert it to packed
         CVB   R0,WORKA            Convert it to Binary                  06446
         ST    R0,SLOTBIN          Store the value for later use         06447
         MVC   LINE,LINE-1
         MVC   LINE(8),FSTFIELD    8-char number with blanks
         MVC   LINE+13(19),=C'Entry slot number  '
         APUT  LINE,32
         LA    R8,1(,R8)           Restore number of chars after EX
         ST    R8,CHARSIZE         Save this value off.
         AR    R3,R8               Add it to R3 so we start past it.
         ST    R3,CHARCONT         Store start value for next parm.
GETNUMEN DS    0H
         L     R9,SAVER9M
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
PRTBLADR DS    0H
         ST    R9,SAVER9N
*-*-*->>                          Print the address out so we can see.
         STM   R14,R1,SAVE1401    Save registers 14 thru 1.
         MVC   LINE,LINE-1        Clear line area.
         MVC   LINE(16),=C'Table address:  '
         HEX   LINE+21,4,TABLADDR     Display address in Hex
         APUT  LINE,35
         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.
*-*-*->>
         L     R9,SAVER9N
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* ----------------------------------------------------------------- *
*      Measure "8-byte entry" loaded table.                         *
* ----------------------------------------------------------------- *
*      R5 contains the entry point of the table.                    *
* ----------------------------------------------------------------- *
MEASUR08 DS    0H                 R5 has beginning address of table.
         ST    R9,SAVER9O           Save BAL register
         ST    R5,SAVER5D           Save work register
         ST    R4,SAVER4B           Save work register
         ST    R6,SAVER6B           Save work register
         L     R5,TABLADDR          Load start of table
         XC    BLNKCNT,BLNKCNT      Zero the counters
         XC    NTRYCNT,NTRYCNT
         LA    R4,16                Count size of header
         LA    R5,16(,R5)           Bump past header
         L     R6,TABLENUM          No of entries to limit loop
ME08LOOP DS    0H
*     Try (real hard) to detect the end of the table  -  below
         MVC   SAVECHAR(1),0(R5)    Save first character
         CLC   =C'        ',0(R5)   Is this table entry a blank?
         BE    ME08BLNK             Yes. Reached virtual end of table
         CLC   ZEROES8(8),0(R5)     Is this "entry" hex zeros?
         BE    ME08NOBL             Yes. Reached possible junk storage
         CLC   =C' ',0(R5)          Is first character blank?
         BE    ME08NOBL             Yes, not a valid table entry.
         TR    SAVECHAR,TRTPGMNM    Check first char if appropriate.
         CLI   SAVECHAR,X'02'       Not. probably end of table.
         BE    ME08NOBL
         CLC   =C'IKJEFTE2',0(R5)
         BE    ME08NOBL
         CLC   =C'IKJEFTE8',0(R5)
         BE    ME08NOBL
         CLC   =C'IKJEFTAP',0(R5)
         BE    ME08NOBL
         CLC   =C'IKJEFTNS',0(R5)
         BE    ME08NOBL
*     Try (real hard) to detect the end of the table  -  above
         LA    R4,8(,R4)            Count next table entry
         LA    R5,8(,R5)            Bump to next entry
         L     R1,NTRYCNT           Increment "entry count" counter
         A     R1,=F'1'
         ST    R1,NTRYCNT
         BCT   R6,ME08LOOP          Loop back till table end
         B     ME08NOBL             No blanks if we fell through
ME08BLNK DS    0H
         LA    R4,8(,R4)            Add length of blank entry
         LA    R5,8(,R5)            Bump past blank entry.
         L     R1,BLNKCNT           Increment "blank entry" counter
         A     R1,=F'1'
         ST    R1,BLNKCNT
ME08NOBL DS    0H
         STH   R4,ME08LENG          Store measured length of table.
         ST    R5,ME08END           And record address of table end.
*        BAL   R9,MESBLK08          Measure more blanks after table.
*        TM    MEASFLG,X'01'        Been here already?
*        BO    ME08NOSH             Don't show count again.
         BAL   R9,ENTRYDSP          Show number of entries.
ME08NOSH DS    0H
*        OI    MEASFLG,X'01'        Show we did this once.
         L     R4,SAVER4B           Restore work register
         L     R6,SAVER6B           Restore work register
         L     R5,SAVER5D           Restore work register
         L     R9,SAVER9O           Restore BAL register
         BR    R9
ME08END  DS    F                    Store end-of-table address
ME08LENG DS    H                    Store table length
BL08LENG DS    H                    Store length of blanks
TO08LENG DS    H                    Store total, nonblank+blank
* ----------------------------------------------------------------- *
MEASUR10 DS    0H                 R5 has beginning address of table.
         ST    R9,SAVER9R           Save BAL register
         ST    R5,SAVER5D           Save work register
         ST    R4,SAVER4B           Save work register
         ST    R6,SAVER6B           Save work register
         L     R5,TABLADDR          Load start of table
         XC    BLNKCNT,BLNKCNT      Zero the counters
         XC    NTRYCNT,NTRYCNT
         LA    R4,16                Count size of header
         LA    R5,16(,R5)           Bump past header
         L     R6,TABLENUM          No of entries to limit loop
ME10LOOP DS    0H
         MVC   SAVECHAR(1),2(R5)    Save first character of pgm name
         MVC   SAVECH08(1),9(R5)    Save last character of pgm name
         CLC   BLKSTRNG(10),0(R5)   Full blank entry here?
         BE    ME10BLNK             Yes. Count the blank entry.
         CLC   ENDSTRNG(10),0(R5)   FFFF plus blank pgm name?
         BE    ME10BLNK             Yes. Can still be considered blank.
         CLC   =X'0000',0(R5)       Zeros in length field?
         BE    ME10TEST             Yes. Test rest of entry.
         B     ME10REST             Not zeros, go on.
ME10TEST DS    0H
         TR    SAVECHAR,TRTPGMNM    Check for strange character.
         CLI   SAVECHAR,X'02'       Is it strange?
         BE    ME10NOBL             Yes. This is not a blank entry.
ME10REST DS    0H
         CLC   =X'FFFF',0(R5)       Test for end string separately.
         BNE   ME10TES2             Not. Not at virtual end of table
         B     ME10NOBL             FFFF alone. Not a blank entry.
ME10TES2 DS    0H
         TR    SAVECHAR,TRTPGMNM    Check for strange character.
         CLI   SAVECHAR,X'02'
         BE    ME10NOBL             Not. probably end of table.
         TR    SAVECH08,TRTPGMNM    Check last char if strange.
         CLI   SAVECH08,X'02'
         BE    ME10NOBL             Not. probably end of table.
         LA    R4,10(,R4)           Count next table entry
         LA    R5,10(,R5)           Bump to next entry
         L     R1,NTRYCNT           Increment "entry count" counter
         A     R1,=F'1'
         ST    R1,NTRYCNT
         BCT   R6,ME10LOOP          Finished entry, try for more.
         B     ME10NOBL
ME10BLNK DS    0H
         LA    R4,10(,R4)           Add length of blank entry
         LA    R5,10(,R5)           Bump past blank entry.
         L     R1,BLNKCNT           Increment "blank entry" counter
         A     R1,=F'1'
         ST    R1,BLNKCNT
ME10NOBL DS    0H
         STH   R4,ME10LENG          Store measured length of table.
         ST    R5,ME10END           And record address of table end.
         BAL   R9,ENTRYDSP          Show number of entries.
ME10NOSH DS    0H
         L     R4,SAVER4B           Restore work register
         L     R6,SAVER6B           Restore work register
         L     R5,SAVER5D           Restore work register
         L     R9,SAVER9R           Restore BAL register
         BR    R9
ME10END  DS    F                    Store end-of-table address
ME10LENG DS    H                    Store table length
BL10LENG DS    H                    Store length of blanks
TO10LENG DS    H                    Store total, nonblank+blank
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ENTRYDSP DS    0H
         ST    R9,SAVER9P
         STM   R14,R1,SAVE1401    Save registers 14 thru 1.
         MVC   LINE,LINE-1
         L     R1,NTRYCNT
         CVD   R1,CVDAREA
         MVC   LINE+22(10),MASK10
         ED    LINE+22(10),CVDAREA+3
         MVC   LINE(24),=C'Non-blank table entries:'
         MVC   LINE+35(25),=C'(these are the ones used)'
         APUT  LINE,65
         MVC   LINE,LINE-1
         L     R1,BLNKCNT
         CVD   R1,CVDAREA
         MVC   LINE+22(10),MASK10
         ED    LINE+22(10),CVDAREA+3
         MVC   LINE(24),=C'Perceived blank entries:'
         MVC   LINE+35(25),=C'(blank program name slot)'
         APUT  LINE,65
         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.
ENTRYEXI DS    0H
         L     R9,SAVER9P
         BR    R9
ENTRYDEN DS    0H
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
PRTNENTR DS    0H
         ST    R9,SAVER9Q
         STM   R14,R1,SAVE1401    Save registers 14 thru 1.
         MVC   LINE,LINE-1
         ST    R1,SAVER1B
         L     R1,TABLENUM         Display field
         CVD   R1,CVDAREA          Convert count to printable
         MVC   LINE+22(10),MASK10  Move in the mask
         ED    LINE+22(10),CVDAREA+3 Make it pretty
         L     R1,SAVER1B
         MVC   LINE(24),=C'Number of valid entries:'
         APUT  LINE,45
         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.
         L     R9,SAVER9Q
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
LISTLNTH DS    0H
         ST    R9,SAVER9S
         STM   R14,R1,SAVE1401    Save registers 14 thru 1.
         MVC   LINE,LINE-1
         MVC   LINE(30),=C'Listed   length of this table:'
         HEX   LINE+32,2,TABLELEN+2
         L     R1,TABLELEN         Display field
         CVD   R1,CVDAREA          Convert count to printable
         MVC   LINE+45(10),MASK10  Move in the mask
         ED    LINE+45(10),CVDAREA+3 Make it pretty
         MVC   LINE+39(8),=C'Decimal:'
         APUT  LINE,65
         TM    NSCHFLG,X'01'
         BO    LISTLN10
         MVC   LINE,LINE-1
         MVC   LINE(30),=C'Measured length of this table:'
         HEX   LINE+32,2,ME08LENG
         LH    R1,ME08LENG         Display field
         CVD   R1,CVDAREA          Convert count to printable
         MVC   LINE+45(10),MASK10  Move in the mask
         ED    LINE+45(10),CVDAREA+3 Make it pretty
         MVC   LINE+39(8),=C'Decimal:'
         APUT  LINE,65
         B     LISTLNEN
LISTLN10 DS    0H
         MVC   LINE,LINE-1
         MVC   LINE(30),=C'Measured length of this table:'
         HEX   LINE+32,2,ME10LENG
         LH    R1,ME10LENG         Display field
         CVD   R1,CVDAREA          Convert count to printable
         MVC   LINE+45(10),MASK10  Move in the mask
         ED    LINE+45(10),CVDAREA+3 Make it pretty
         MVC   LINE+39(8),=C'Decimal:'
         APUT  LINE,65
LISTLNEN DS    0H
         LM    R14,R1,SAVE1401    Restore registers 14 thru 1.
         L     R9,SAVER9S
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
BLKSTRNG DC    XL10'00004040404040404040'
ENDSTRNG DC    XL10'FFFF4040404040404040'
ZEROES8  DC    X'0000000000000000'
MASK10   DC    XL10'40202020202020202120'
         DC    C' '
BLANKS   DC    C'                                            '
MESSAGET DC    C'ASUB Command - Display or Change PARMLIB Auth Table Enx
               try - Ver 1.15'
MESSAGEU DC    C'---- -------   ------- -- ------ ------- ---- ----- --x
               ---   --- ----'
MESSAG2C DC    C'Command was not invoked APF authorized.'
MESSAG2D DC    C'Nothing was changed.  '
MESSAG3A DC    C'Slot      in XX table has been changed to         .'
MESSAG3B DC    C'Last slot in XX table has been blanked.            '
MESSAG3C DC    C'                                                      +
                  '
MESSA11A DC    C'Supply a table code, followed by an action code. '
MESSA11B DC    C'Supply a program name, as the next parameter.   '
MESSA11C DC    C'Valid table  codes are:  E2, E8, AP, NS, PC, PP. '
MESSA11D DC    C'Valid action codes are:  R - replace, B - blank, D - d-
               isplay.'
MESSA11E DC    C'Please supply a program name.  '
MESSA11F DC    C'Full command is in the form TTA, TT=table code, A=acti-
               on code.'
MESSA11G DC   C'Please supply slot number to change, and program name.'
MESSA11H DC    C'This table did not come from a PARMLIB specification.'
MESSA11I DC    C'If D (display) is followed by a slot number, only that-
                slot is shown.'
MESSA11J DC    C'R (replace) requires a slot number, followed by a prog-
               ram name.'
MESSA11K DC    C'If D is not followed by a number, then the entire tabl-
               e is displayed.'
MESSA11L DC    C'  Instructions to use this program:                  '
MESSA11M DC    C'  ------------ -- --- ---- -------                   '
MESSA11N DC    C'B (blank) will blank the last table entry, which norma-
               lly is blank.'
MESSA11O DC    C'Only R (replace) and B (blank) require APF authorizati-
               on. D does not.'
MESSA11P DC    C'  ASUB TTA nnn pgmname (nnn optional for D, both requi-
               red for R)'
MESSAGR0 DC    C'Return Code = 0 '
MESSAGR4 DC    C'Return Code = 4 '
MESSAGR8 DC    C'Return Code = 8 '
MESSAGRC DC    C'Return Code = 12'
MESSDIAG DC    C'                                            '
MESSAGEP DC    C'No Parmlib-supplied XX table was found in storage. '
MESSAGEN DC    C'Supplied character        was not numeric. '
         SPACE 3
         LTORG
         SPACE 3
CVDAREA  DS    D                   For CVD instruction
SAVEAPUT DS    2D
SAVER1   DS    F                   Save R1 here
SAVER1A  DS    F                   Save R1 here
SAVER1B  DS    F                   Save R1 here
SAVER3A  DS    F                   Save R3 here
SAVER4A  DS    F                   Save R4 here
SAVER4B  DS    F                   Save R4 here
SAVER5A  DS    F                   Save R5 here
SAVER5D  DS    F                   Save R5 here
SAVER6   DS    F                   Save R6 here
SAVER6A  DS    F                   Save R6 here
SAVER6B  DS    F                   Save R6 here
SAVER8   DS    F                   Save R8 here
SAVER8A  DS    F                   Save R8 here
SAVER8B  DS    F                   Save R8 here
SAVER9A  DS    F                   BAL Register Save Area
SAVER9B  DS    F                   BAL Register Save Area
SAVER9C  DS    F                   BAL Register Save Area
SAVER9D  DS    F                   BAL Register Save Area
SAVER9E  DS    F                   BAL Register Save Area
SAVER9F  DS    F                   BAL Register Save Area
SAVER9G  DS    F                   BAL Register Save Area
SAVER9H  DS    F                   BAL Register Save Area
SAVER9I  DS    F                   BAL Register Save Area
SAVER9J  DS    F                   BAL Register Save Area
SAVER9K  DS    F                   BAL Register Save Area
SAVER9L  DS    F                   BAL Register Save Area
SAVER9M  DS    F                   BAL Register Save Area
SAVER9N  DS    F                   BAL Register Save Area
SAVER9O  DS    F                   BAL Register Save Area
SAVER9P  DS    F                   BAL Register Save Area
SAVER9Q  DS    F                   BAL Register Save Area
SAVER9R  DS    F                   BAL Register Save Area
SAVER9S  DS    F                   BAL Register Save Area
SAVER9T  DS    F                   BAL Register Save Area
SAVER9U  DS    F                   BAL Register Save Area
SAVER9V  DS    F                   BAL Register Save Area
SAVER9W  DS    F                   BAL Register Save Area
SAVER9X  DS    F                   BAL Register Save Area
SAVER9Y  DS    F                   BAL Register Save Area
CMBUFEND DS    F                   Number of bytes to end of cmd buff
SAVLSLOT DS    F                   Save place where Key 0 will change
SLOTBIN  DS    F
SLOTNOW  DS    F
DISPREG  DS    F                   DISPLAY
CMBUFAD  DS    F                   Command Buffer address
CHARSTRT DS    F                   Address of first parm character
CHARCONT DS    F                   Address of next parm character
CHARSIZE DS    F
OURSLOT  DS    F
* --- >
TABLSTRT DS    F                   Start address of table
TABLADDR DS    F                   Start address of table
TABLENUM DS    F                   Number of entries in table
TABLESIZ DS    F                   Size of a table entry
TABLELEN DS    F                   Listed length of the table
* --- >
BLNKCNT  DS    F
NTRYCNT  DS    F
* --- >
OFFSETSV DS    F
WORKA    DC    D'0'                                                      06772
NUMVSTRT DC    X'00'               Character count of first parm
NUMCOUTL DC    X'00'               Entered first parm length
CODEPLAC DS    CL2
PAD01    DS    CL4                 Filler
SAVECHAR DS    X
SAVECH08 DS    X
OFFFLAG  DS    X                   Are we blanking the last entry?
OLDFLAG  DS    X                   Old system detected if X'01'
PLATFLG  DS    X
NSCHFLG  DS    X
PAD02    DS    CL4                 Filler
FSTNAME  DC    CL8' '
FSTCOUNT DS    F                   Number of characters in FSTNAME
FSTCHALF DC    H'0'
PAD03    DS    CL4                 Filler
FSTFIELD DS    0CL8
FSTNUME  DC    CL5' '
FSTNUPAD DC    CL3' '
FSTNOUNT DS    F                   Number of characters in FSTNAME
FSTNHALF DC    H'0'
PAD04    DS    CL4                 Filler
SLOTSAVE DS    CL10
PAD05    DS    CL4                 Filler
SNDNAME  DC    CL8' '
SNDCOUNT DS    F                   Number of characters in SNDNAME
SNDCHALF DC    H'0'
TABCODE  DC    CL8' '              Original OUTLIM character
TABENNUM DC    CL10' '
         DS    CL7                 PADDING
         DS    CL1
CMDBCOPY DS    CL252
         DS    CL128               PADDING
         DS    0F                  ALIGN ON FULLWORD
LINEB    DS    C                   LINE-1
LINE     DS    CL137               Output line area
LINET    EQU   LINE+7              Indented line
TRTPGMNM DC    X'02020202020202020202020202020202'
         DC    X'02020202020202020202020202020202'
         DC    X'02020202020202020202020202020202'
         DC    X'02020202020202020202020202020202'
         DC    X'40020202020202020202020202020202'
         DC    X'02020202020202020202025B02020202'
         DC    X'0202020202020202020202020202026F'
         DC    X'02020202020202020202027B7C020202'
         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'
         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'
         DC    X'0202E2E3E4E5E6E7E8E9020202020202'
         DC    X'02020202020202020202020202020202'
         DC    X'02C1C2C3C4C5C6C7C8C9020202020202'
         DC    X'02D1D2D3D4D5D6D7D8D9020202020202'
         DC    X'0202E2E3E4E5E6E7E8E9020202020202'
         DC    X'02020202020202020202020202020202'
         SPACE
         IKJCPPL
         IKJPSCB
         CVT      LIST=YES,DSECT=YES
         IKJTSVT
         END
EPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&
               OR'
EPUTL    CSECT                                              *HMD 10/85*
         LCLB  &XA                                          *HMD 10/85*
&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  MODULE NAME  . . . . EPUTL
*
*  ALIASES  . . . . . . NONE
*
*  DATE WRITTEN . . . . 06/85
*  UPDATED      . . . . 04/88                                  HD APR88
*
*  AUTHOR . . . . . . . JIM ELSWORTH
*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88
*
*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR
*
*  PURPOSE:
*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE
*
*
*  DESCRIPTION:
*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.
*    ISSUES SINGLE LINE PUTLINE.
*
*
*  ATTRIBUTES:
*    REENTRANT
*
*  FEATURES:
*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.
*
*  CALLED MODULES:
*    PUTLINE
*
*  ASSUMPTIONS:
*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE
*
*  ABENDS:
*    POSSIBLE 0CX IF BAD ARGUEMNTS
*
*  CAVEATS:
*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB
*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.
*
*
*  INPUT ARGUMENTS:
*    1)  R1 : ADDRESS OF MESSAGE TEXT
*    2)  R0 : LENGTH OF MESSAGE TEXT
*    3) R13 : STANDARD OS SAVE AREA
*    4) R14 : RETURN ADDRESS
*    5) R15 : ENTRY ADDRESS
*
*               ( CONTINUED ... )
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR
*
RCBA     EQU   100                 BAD MESSAGE ADDRESS
RCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG
*
MAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH
*
*
*  REGISTERS USED:
*
R0       EQU   0                   MESSAGE LENGTH AT ENTRY
R1       EQU   1                   MESSAGE ADDRESS AT ENTRY
R2       EQU   2                   WORK
RMA      EQU   4                   @MESSAGE TEXT
RML      EQU   5                   MESSAGE LENGTH
RUPT     EQU   6                   @UPT (USER PROFILE TABLE)
RECT     EQU   7                   @ECT
R12      EQU   12                  CSECT BASE
R13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA
R14      EQU   14                  WORK/LINKAGE
R15      EQU   15                  WORK/LINKAGE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
         IKJCPPL
         EJECT
         IKJTCB   LIST=YES                                  *HMD 10/85*
         EJECT                                              *HMD 10/85*
         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*
         EJECT
         IHAPSA   LIST=YES                                     HD APR88
         EJECT                                                 HD APR88
PUTLDS   DSECT
         DS    18F                      OS SAVE AREA
PUTAAA   EQU   *
PUTECB   DS    F                        ECB
PUTIOPL  DS    4F                       IOPLADS
PUTBLOK  PUTLINE MF=L
PUTLEN   DS    H                        LENGTH
PUTZZZ   DS    H                        RESERVED
PUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA
PUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS
         EJECT
***********************************************************************
*  SET UP LINKAGE
***********************************************************************
         SPACE 1
EPUTL    CSECT
         AIF  (NOT &XA).X001                                *HMD 10/85*
EPUTL    AMODE 31
.X001    ANOP                                               *HMD 10/85*
         STM   14,12,12(13)       SAVE CALLERS REGS
         LR    R12,R15            COPY EPA
         USING EPUTL,R12          ADDRESSABILITY
         AIF   (NOT &XA).X002                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &
               LOC=RES            RELATIVE TO 16MB LINE
         AGO   .X003                                        *HMD 10/85*
.X002    ANOP                                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA
.X003    ANOP                                               *HMD 10/85*
         ST    1,8(13)            OUR SAVE AREA POINTER
         ST    13,4(1)            POINTER TO CALLERS SAVE AREA
         LR    13,1               @OUR SAVE AREA
         USING PUTLDS,R13         MAP SA AND WORK AREA
         L     R14,4(R13)         POINT TO CALLERS RSA
         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN
         SPACE 2
***********************************************************************
*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE
***********************************************************************
         SPACE 1
         LA    R15,RCBA                 ASSUME BAD ADDRESS
         LTR   RMA,R1                   MESSAGE ADDRESS
         BNP   RETURN                   GOOD ASSUMPTION
         LA    R15,RCBL                 ASSUME BAD LENGTH
         LTR   RML,R0                   POSITIVE?
         BNP   RETURN                   -NO
         C     RML,=A(MAXMSG)           MORE THAN MAX?
         BH    RETURN                   -YES
         SPACE 2
***********************************************************************
*  BUILD PARAMETER LIST
***********************************************************************
         SPACE 1
         LA    R15,4(RML)               MESSAGE LENGTH
         STH   R15,PUTLEN                 PLUS HEADER
         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW
         BCTR  RML,0                    REDUCE FOR MOVE
         EX    RML,PUTMOVE
         EJECT
***********************************************************************
*  DIG UP ADDRESS OF UPT AND ECT
***********************************************************************
         SPACE 1
         L     R2,PSATOLD-PSA           @TCB                   HD APR88
         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA
         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP
         USING CPPL,R2                  MAP CPPL
         L     RUPT,CPPLUPT             @UPT
         L     RECT,CPPLECT             @ECT
         SPACE 2
***********************************************************************
*  ISSUE PUTLINE CALL
***********************************************************************
         SPACE 1
         XC    PUTECB,PUTECB            CLEAR ECB
         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88
         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &
               UPT=(RUPT),              @UPT                           &
               ECT=(RECT),              @ECT                           &
               ECB=PUTECB,              @ECB                           &
               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &
               MF=(E,PUTIOPL)
         EJECT
***********************************************************************
*  RETURN TO CALLER
***********************************************************************
         SPACE 1
RETURN   EQU   *
         LR    2,R13                    @OUR SAVE AREA
         LR    3,R15                    SAVE RETURN CODE
         L     R13,4(R13)               @CALLERS SAVE AREA
         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0
         LR    R15,3                    RESTORE RC
         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS
         SPACE 5
***********************************************************************
*  CONSTANTS AND NON-REENTRANT WORK AREAS
***********************************************************************
         SPACE 1
PUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER
         SPACE 2
         LTORG
         SPACE 2
         END   EPUTL
